{"version":3,"sources":["components/Ball.js","components/Container.js","App.js","index.js"],"names":["Ball","props","state","setInitialState","key","ballKey","mounted","this","animationID","setInterval","setPosition","clearInterval","positionX","positionY","boundaries","movingForward","getRandom","movingUp","currentSpeedY","setSpeed","currentSpeedX","distanceTraveled","isMoving","Math","floor","random","speedChoice","isAtBottom","newState","newPositionX","newPositionY","updateSpeedY","updateSpeedX","handleBoundaries","removeBall","setState","bottom","right","left","top","abs","myStyle","borderStyle","height","width","backgroundColor","borderRadius","position","style","Component","Container","createBall","e","persist","myKey","count","newBall","pageX","pageY","newBalls","balls","containerRef","React","createRef","bind","boundingRectangle","current","getBoundingClientRect","filter","ball","margin","onClick","ref","data-testid","map","item","App","className","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.076baa68.chunk.js","sourcesContent":["/**\r\n * This class is responsible for everything related to animating the balls.\r\n * Each ball animates itself by leveraging the event loop to call a setPosition() method on a set interval.\r\n */\r\nimport React, {Component} from 'react';\r\n\r\nclass Ball extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = this.setInitialState(props);\r\n        this.key = props.ballKey;\r\n        this.mounted = false;\r\n    }\r\n\r\n    /**\r\n     * React lifecycle method. This method begins the animation by calling setPosition() on a given interval.\r\n     */\r\n    componentDidMount() {\r\n        this.mounted = true;\r\n        this.animationID = setInterval(() => this.setPosition(), 17);  // 17ms interval to approximate a 60fps animation\r\n    }\r\n\r\n    /**\r\n     * React lifecycle method. This method releases the setPosition() call.\r\n     */\r\n    componentWillUnmount() {\r\n        this.mounted = false;\r\n        clearInterval(this.animationID);\r\n    }\r\n\r\n    /**\r\n     * Sets the initial state by randomly choosing the direction and speed.\r\n     * @param {object} props The props passed in to the constructor of this object.\r\n     */\r\n    setInitialState(props) {\r\n        /**\r\n         * Changing these values affect how often a ball starts moving in a given direction.\r\n         * Lower horizontalDirectionThreshold means the ball will start by moving to the right more often than not.\r\n         * Lower verticalDirectionThreshold means the ball will start by moving up more often than not.\r\n         */\r\n        const horizontalDirectionThreshold = 5;\r\n        const verticalDirectionThreshold = 5;\r\n        \r\n        return {\r\n            positionX: props.positionX,\r\n            positionY: props.positionY,\r\n            boundaries: props.boundaries,\r\n            movingForward: (this.getRandom() > horizontalDirectionThreshold) ? true : false,\r\n            movingUp: (this.getRandom() > verticalDirectionThreshold) ? true : false,\r\n            currentSpeedY: this.setSpeed(),\r\n            currentSpeedX: this.setSpeed(),\r\n            distanceTraveled: 0,\r\n            isMoving: true\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper method for randomly choosing speed and direction. Returns a number between 1 and 10 inclusive.\r\n     */\r\n    getRandom() {\r\n        return Math.floor((Math.random() * 10) + 1);\r\n    }\r\n\r\n    /**\r\n     * Sets the speed based on a random number.\r\n     */\r\n    setSpeed() {\r\n        const speedChoice = this.getRandom();\r\n        const slow = 3;\r\n        const medium = 6;\r\n        const fast = 9;\r\n        \r\n        if (speedChoice < 4) {\r\n            return slow;\r\n        } else if (speedChoice < 7) {\r\n            return medium;\r\n        } else {\r\n            return fast;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a new speed based on the current direction. Returns a number that represents the new speed.\r\n     * @param {object} state The current state of the ball\r\n     */\r\n    updateSpeedY(state) {\r\n        let newSpeed;\r\n\r\n        // Slow down if moving up, otherwise speed up\r\n        (state.movingUp) ? newSpeed = state.currentSpeedY - 1 : newSpeed = state.currentSpeedY + 1;\r\n\r\n        return newSpeed;\r\n    }\r\n\r\n    /**\r\n     * Sets a new speed in the X direction. The speed is updated based on the position of the ball. It only reduces the speed \r\n     * if the ball is rolling at the bottom of the container.\r\n     * @param {object} state The current state of the ball\r\n     */\r\n    updateSpeedX(state) {\r\n        const speedYThreshold = 2;  // Even when the ball is rolling at the bottom, sometimes it has a Y speed of 1.\r\n        \r\n        /**\r\n         * How far the ball should roll before changing the speed.\r\n         * The higher this number, the longer the ball will roll before stopping.\r\n         */\r\n        const travelDistanceThreshold = 20;\r\n\r\n        if(\r\n            this.isAtBottom(state) && \r\n            !state.movingUp && \r\n            state.currentSpeedY < speedYThreshold && \r\n            state.currentSpeedX > 0 && \r\n            state.distanceTraveled % travelDistanceThreshold === 0) {\r\n            \r\n            return state.currentSpeedX - 1;\r\n        } else {\r\n            return state.currentSpeedX;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Calculates the new position of the ball on each interval. Copies the current state object and sets new values relating to \r\n     * position, speed, and distance. Finally, calls setState() with the new state object which triggers react to render the ball again.\r\n     */\r\n    setPosition() {\r\n        let newState = {...this.state}\r\n        let newPositionX = this.state.positionX;\r\n        let newPositionY = this.state.positionY;\r\n\r\n        /**\r\n         * Use the speed to determine how much the position should change.\r\n         * Evaluate the direction to determine if the change should be positive or negative.\r\n         * The signs for the Y position are counterintuitive because the smaller Y coordinates are near the top of the screen.\r\n         */\r\n        (this.state.movingForward) ? newPositionX += this.state.currentSpeedX : newPositionX -= this.state.currentSpeedX;\r\n        (this.state.movingUp) ? newPositionY -= this.state.currentSpeedY : newPositionY += this.state.currentSpeedY;\r\n\r\n        newState.positionX = newPositionX;\r\n        newState.positionY = newPositionY;\r\n        newState.distanceTraveled += 1;  // distanceTraveled determines when the speed is updated\r\n\r\n        if(newState.distanceTraveled % 5 === 0) {  // update the speed every 5 iterations\r\n            newState.currentSpeedY = this.updateSpeedY(newState);\r\n            newState.currentSpeedX = this.updateSpeedX(newState);\r\n\r\n            if(newState.currentSpeedY === 0 && !this.isAtBottom(newState)) {  // At the height of the curve, change the direction\r\n                newState.movingUp = !newState.movingUp;\r\n            }\r\n        }\r\n\r\n        newState = this.handleBoundaries(newState);\r\n        newState.isMoving = this.isMoving(newState);\r\n\r\n        if(!newState.isMoving) {  // Remove the ball from the app once it stops moving\r\n            this.props.removeBall(this.key);\r\n        }\r\n\r\n        if(this.mounted) {  // Don't attempt to set state after ball has unmounted, this fixes the memory leak warning.\r\n            this.setState(newState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the ball is at the bottom of the container\r\n     * @param {Object} state The current state of the ball\r\n     */\r\n    isAtBottom(state) {\r\n        return (state.boundaries.bottom - state.positionY === 1) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ball is still moving. The ball is considered to be moving if either the Y speed is above the threshold \r\n     * or the X speed is greater than 0.\r\n     * @param {object} state The current state of the ball\r\n     */\r\n    isMoving(state) {\r\n        const speedYThreshold = 2;\r\n        return (state.currentSpeedY < speedYThreshold && state.currentSpeedX === 0) ? false : true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ball is at any of the container boundaries. Switches the direction and calculates a new speed if so.\r\n     * @param {object} state The current state of the ball\r\n     */\r\n    handleBoundaries(state) {\r\n        // The minimum speed to calculate a bounce for. Using a lower threshold causes the ball to bounce forever.\r\n        const speedThreshold = 4;\r\n        let newState = {...state};\r\n\r\n        if(state.positionX >= state.boundaries.right || state.positionX <= state.boundaries.left) {  // Reverse the direction if the ball is at a boundary\r\n            newState.movingForward = !state.movingForward;\r\n\r\n            // Fix for the edge case where the ball can vibrate around the boundary\r\n            if(state.positionX >= state.boundaries.right) {\r\n                newState.positionX = state.boundaries.right - 1;\r\n            } else if(state.positionX <= state.boundaries.left) {\r\n                newState.positionX = state.boundaries.left + 1;\r\n            }\r\n        }\r\n\r\n        if(state.positionY <= state.boundaries.top) {\r\n            newState.movingUp = !state.movingUp;\r\n            \r\n            // Set position just inside of the boundary so that the method doesn't get called again in case the position was outside of the boundary\r\n            newState.positionY = state.boundaries.top + 1;\r\n        } else if(state.positionY >= state.boundaries.bottom) {\r\n            \r\n            // Set position just inside of the boundary so that the method doesn't get called again in case the position was outside of the boundary\r\n            newState.positionY = state.boundaries.bottom - 1;\r\n            \r\n            if(Math.abs(state.currentSpeedY) >= speedThreshold) {\r\n                newState.movingUp = !state.movingUp;\r\n\r\n                // Reduce the speed by about 50% until the speed threshold is hit, then reduce the speed to 0\r\n                newState.currentSpeedY = state.currentSpeedY - Math.floor(state.currentSpeedY / 2);\r\n            } else {\r\n                newState.movingUp = false;\r\n                newState.currentSpeedY = 0;\r\n            }\r\n        }\r\n\r\n        return newState;\r\n    }\r\n    \r\n    /**\r\n     * React lifecycle method. This method shows the ball on the screen. It is called when the ball is instantiated, \r\n     * and also anytime the state is updated. The animation works because the state is constantly updated with new positions,\r\n     * and the positions are used in the css rules.\r\n     */\r\n    render() {\r\n        let myStyle = {\r\n            borderStyle: \"solid\",\r\n            height: \"15px\",\r\n            width: \"15px\",\r\n            backgroundColor: \"red\",\r\n            borderRadius: \"50%\",\r\n            position: \"fixed\",\r\n            top: this.state.positionY,\r\n            left: this.state.positionX\r\n        }\r\n\r\n        if(this.state.isMoving) {\r\n            return (\r\n                <span style={myStyle}></span>\r\n            )\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport default Ball;\r\n","/**\r\n * This class has 3 main responsibilities:\r\n *  - Add balls to the app\r\n *  - Remove balls from the app\r\n *  - Define the boundaries for the balls in the app\r\n */\r\nimport React, {Component} from 'react';\r\nimport Ball from './Ball';\r\n\r\nclass Container extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            count: 0,\r\n            balls: [],\r\n            boundaries: {}\r\n        }\r\n\r\n        // Create a reference that will be used later to get the <div> that encapsulates this component.\r\n        this.containerRef = React.createRef();\r\n\r\n        // Allow the child to call this method with a reference to the container.\r\n        this.removeBall = this.removeBall.bind(this);\r\n    }\r\n\r\n    /**\r\n     * React lifecycle hook. After the container is rendered, get the boundaries and add them to the state.\r\n     */\r\n    componentDidMount() {\r\n        const boundingRectangle = this.containerRef.current.getBoundingClientRect();\r\n        const borderOffset = 15;  // offset the borders so that the ball appears to bounce off the walls.\r\n        \r\n        const boundaries = {\r\n            left: boundingRectangle.left,\r\n            right: boundingRectangle.right - borderOffset,\r\n            top: boundingRectangle.top,\r\n            bottom: boundingRectangle.bottom - borderOffset\r\n        }\r\n\r\n        this.setState((state) => {\r\n            state.boundaries = boundaries\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a new ball to screen. Works by adding the ball to the state, and then calling setState() which\r\n     * causes react to redraw the component and all the children. This method is called when the user clicks\r\n     * within the container.\r\n     * @param {*} e The event object that triggered this callback.\r\n     */\r\n    createBall = (e) => {\r\n        e.persist();  // persist the virtual event object, otherwise all the data inside will be null.\r\n        const myKey = `ball_${this.state.count}`\r\n        \r\n        const newBall = [{\r\n            key: myKey,\r\n            ballKey: myKey,  // key is a special prop which is not accesible in the child\r\n            positionX: e.pageX,\r\n            positionY: e.pageY,\r\n            boundaries: this.state.boundaries,\r\n            removeBall: this.removeBall\r\n        }];\r\n        \r\n        /**\r\n         * Rule of thumb in react is to never mutate the state,\r\n         * so create a new list by appending the new ball to the old list. Also create a new state object.\r\n         */\r\n        const newBalls = [...this.state.balls, ...newBall]\r\n        const newState = {\r\n            count: this.state.count + 1,\r\n            balls: newBalls\r\n        }\r\n        \r\n        this.setState(newState);\r\n    }\r\n\r\n    /**\r\n     * Removes the ball based on the key\r\n     * @param {string} key The key of the ball to remove\r\n     */\r\n    removeBall(key) {\r\n        // I chose to use array.filter() because it returns a new array, which maintains immutability.\r\n        const newBalls = this.state.balls.filter((ball) => {return ball.key !== key; });\r\n\r\n        this.setState({balls: newBalls});\r\n    }\r\n    \r\n    /**\r\n     * React lifecycle hook. This method draws the component on the screen. It is called after the component is\r\n     * first instantiated, and also every time the state is updated.\r\n     */\r\n    render() {\r\n        // I chose to define css styles as a javascript object because they are relatively simple.\r\n        const myStyle = {\r\n            borderStyle: \"solid\",\r\n            height: \"420px\",\r\n            width: \"75%\",\r\n            margin: \"50px\",\r\n            position: \"relative\"\r\n        }\r\n\r\n        return (\r\n            <div \r\n                style={myStyle}\r\n                onClick={this.createBall}  // bind the onClick event to the createBall() method defined earlier\r\n                \r\n                /**\r\n                 * Bind the containerRef object created earlier to this DOM element.\r\n                 * This allows me to get the size of the <div> using getBoundingClientRect().\r\n                 */\r\n                ref={this.containerRef}\r\n                data-testid=\"myContainer\">  \r\n                {\r\n                    /**\r\n                     * Create a Ball component for each element in balls array in the state.\r\n                     * The information in each element is passed to the component as props.\r\n                     */\r\n                    this.state.balls.map((item) => (\r\n                        <Ball {...item}></Ball>\r\n                    ))\r\n                }\r\n            </div>\r\n        )\r\n    }\r\n\r\n}\r\n\r\nexport default Container;\r\n","import React from 'react';\nimport './App.css';\nimport Container from './components/Container';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>Yieldify Interview</h1>\n      <Container />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}